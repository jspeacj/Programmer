package Level2;

public class PseudoCantorBitString {
    public static void main(String[] args) {
        /*
            유사 칸토어 비트열

            문제 설명
            수학에서 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합으로,
            [0, 1]부터 시작하여 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만들어집니다.

            남아는 칸토어 집합을 조금 변형하여 유사 칸토어 비트열을 만들었습니다.
            유사 칸토어 비트열은 다음과 같이 정의됩니다.

            0 번째 유사 칸토어 비트열은 "1" 입니다.
            n(1 ≤ n) 번째 유사 칸토어 비트열은 n - 1 번째 유사 칸토어 비트열에서의 1을 11011로 치환하고 0을 00000로 치환하여 만듭니다.
            남아는 n 번째 유사 칸토어 비트열에서 특정 구간 내의 1의 개수가 몇 개인지 궁금해졌습니다.
            n과 1의 개수가 몇 개인지 알고 싶은 구간을 나타내는 l, r이 주어졌을 때 그 구간 내의 1의 개수를 return 하도록 solution 함수를 완성해주세요.

            제한사항
            1 ≤ n ≤ 20
            1 ≤ l, r ≤ 5n
            l ≤ r < l + 10,000,000
            l과 r은 비트열에서의 인덱스(1-base)이며 폐구간 [l, r]을 나타냅니다.

            입출력 예
            n	l	r	result
            2	4	17	  8

            입출력 예 설명
            2 번째 유사 칸토어 비트열은 "1101111011000001101111011" 입니다.
            음영 표시된 부분은 폐구간 [4, 17] 이며 구간 내의 1은 8개 있습니다.
         */

        /* TC 1 result : 8 */
        int n = 2;
        int l = 4;
        int r = 17;

        /*
           문제 이해하기 :
           "1" => "11011"
           "0" => "00000"

            0번쨰 : "1" => 1의 개수 : 1개 (비트열 개수 : 1개)
            1번쨰 : "11011" => 1의 개수 : 4개 (비트열 개수 : 5개)
            2번째 : "11011110110
            00001101111011" => 1의 개수 : 16개 (비트열 개수 : 25개)
            3번쨰 : "11011110110000011011110111101111011000001101111011000000000000000000000000011011110110000011011110111101111011000001101111011" => 1의 개수 : 64개 (비트열 개수 : 125)
            4번쨰 : "비트열 생략" => 1의 개수 : 256개 (비트열 개수 : 625)
                   ...
            n번쨰 : n-1번째 치환 => 1의 개수 : 4의 n제곱근 (비트열 개수 : 5의 n제곱근)

            규칙 :
                1. n번쨰일때 해당 비트열의 모든 1의 개수는 4의 n 제곱근이다.
                2. 비트열의 총 개수는 5의 n 제곱근이다.
                3. 1의 개수는 비트열의 가운데 위치((비트열 개수 -1) / 2)를 기준으로 절반씩 나눠져있다.
                4. 각 유사 칸토어 비트열은 몇번째이든 상관없이 각 비트의 인덱스의 값은 동일하다. (ex. 2번째 칸토어 비트열의 4번째 인덱스 : 1, 3번째 칸토어 비트열의 4번째 인덱스 : 1)

            문제 해결 방식 :
             위 규칙 내용에 따라, 실질적으로 필요한 구간은 [l, r]까지 이기 때문에, 반복문을 이용하여 비트열을 찾다가, 비트열의 개수가 해당 인덱스보다 클 경우 반복문을 종료한다.
             (해당 구간 이후는 쓸모가 없기 때문에 더 찾을 필요가 없음)
             => 해당 방식으로 시도하니깐 메모리 초과가 발생함.

             "n번쨰의 총 개수는 5(j)승이고, n번쨰의 "1"의 값은 4(k)승이다."
             위 규칙을 참고한 상태로 주어진 r,l의값을 아래 방식을 이용하여 구한 값 (0부터 r까지의 1 개수) - (0부터 l까지의 1개수) 값이 정답이다.
             (아래는 r값이 30일 경우를 기준으로 규칙을 설명한다.)
             1. 주어진 r의 값이 5(j)승의 어느 사이에 있는지 찾는다. (ex. 주어진 r 값이 30일 경우 5(2) = 25 < r(30) < 5(3) = 125)
             2. 주어진 r값 보다 더 큰 5(j)에서 j 값은 2가 되므로, n = 2일 떄 1의 개수를 rResult 값에 더해둔다.
             3. 이떄 r값은 5자리가 더 남기때문에 해당 값을 기준으로 찾아야한다.

             새로운 규칙 :
             1. n번쨰 칸토어 비트열은 (n-1) + (n-1) + ("0" * 5(n)승) + (n-1) + (n-1)로 되어있다.
             2. 즉 각 칸토어 비트열은 5개의 구역으로 나눌수가 있다.
             3. 5개의 구역으로 나눌 경우 가운데 구역은 무조건 0밖에 없으며, n번쨰 칸토어 비
        */

        /* 수학적 규칙이 필요해서 결국 다른 사람꺼 코드 참고함.. */
        int answer = 0;

        for (l--; l < r; l++) {
            if (check(l)) answer++;
        }

        System.out.println(answer);
    }

    public static boolean check(long l) {
        if (l < 5 && l != 2) return true;
        if ((l - 2) % 5 == 0) return false;

        return check(l / 5);
    }
}
