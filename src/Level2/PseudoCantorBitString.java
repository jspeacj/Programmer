package Level2;

public class PseudoCantorBitString {
    public static void main(String[] args) {
        /*
            유사 칸토어 비트열

            문제 설명
            수학에서 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합으로,
            [0, 1]부터 시작하여 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만들어집니다.

            남아는 칸토어 집합을 조금 변형하여 유사 칸토어 비트열을 만들었습니다.
            유사 칸토어 비트열은 다음과 같이 정의됩니다.

            0 번째 유사 칸토어 비트열은 "1" 입니다.
            n(1 ≤ n) 번째 유사 칸토어 비트열은 n - 1 번째 유사 칸토어 비트열에서의 1을 11011로 치환하고 0을 00000로 치환하여 만듭니다.
            남아는 n 번째 유사 칸토어 비트열에서 특정 구간 내의 1의 개수가 몇 개인지 궁금해졌습니다.
            n과 1의 개수가 몇 개인지 알고 싶은 구간을 나타내는 l, r이 주어졌을 때 그 구간 내의 1의 개수를 return 하도록 solution 함수를 완성해주세요.

            제한사항
            1 ≤ n ≤ 20
            1 ≤ l, r ≤ 5n
            l ≤ r < l + 10,000,000
            l과 r은 비트열에서의 인덱스(1-base)이며 폐구간 [l, r]을 나타냅니다.

            입출력 예
            n	l	r	result
            2	4	17	  8

            입출력 예 설명
            2 번째 유사 칸토어 비트열은 "1101111011000001101111011" 입니다.
            음영 표시된 부분은 폐구간 [4, 17] 이며 구간 내의 1은 8개 있습니다.
         */

        /* TC 1 result : 8 */
        int n = 2;
        int l = 4;
        int r = 17;

        /*
           문제 이해하기 :
           "1" => "11011"
           "0" => "00000"

            0번쨰 : "1" => 1의 개수 : 1개 (비트열 개수 : 1개)
            1번쨰 : "11011" => 1의 개수 : 4개 (비트열 개수 : 5개)
            2번째 : "11011110110
            00001101111011" => 1의 개수 : 16개 (비트열 개수 : 25개)
            3번쨰 : "11011110110000011011110111101111011000001101111011000000000000000000000000011011110110000011011110111101111011000001101111011" => 1의 개수 : 64개 (비트열 개수 : 125)
            4번쨰 : "비트열 생략" => 1의 개수 : 256개 (비트열 개수 : 625)
                   ...
            n번쨰 : n-1번째 치환 => 1의 개수 : 4의 n제곱근 (비트열 개수 : 5의 n제곱근)

            규칙 :
                1. n번쨰일때 해당 비트열의 모든 1의 개수는 4의 n 제곱근이다.
                2. 비트열의 총 개수는 5의 n 제곱근이다.
                3. 1의 개수는 비트열의 가운데 위치((비트열 개수 -1) / 2)를 기준으로 절반씩 나눠져있다.
                4. 각 유사 칸토어 비트열은 몇번째이든 상관없이 각 비트의 인덱스의 값은 동일하다. (ex. 2번째 칸토어 비트열의 4번째 인덱스 : 1, 3번째 칸토어 비트열의 4번째 인덱스 : 1)

            문제 해결 방식 :
             위 규칙 내용에 따라, 실질적으로 필요한 구간은 [l, r]까지 이기 때문에, 반복문을 이용하여 비트열을 찾다가, 비트열의 개수가 해당 인덱스보다 클 경우 반복문을 종료한다.
             (해당 구간 이후는 쓸모가 없기 때문에 더 찾을 필요가 없음)
        */

        int answer = 0;
        StringBuilder sb = new StringBuilder();
        String finalStr = "";
        String str = "";
        sb.append("1");

        while (true) {
            if (sb.length() >= r) {
                finalStr = sb.substring((int)l-1, (int)r);
                break;
            }

            str = sb.toString();
            sb.setLength(0);

            for (char c : str.toCharArray()) {
                if (c == '1') {
                    sb.append("11011");
                } else {
                    sb.append("00000");
                }
            }
        }

        for (char c : finalStr.toCharArray()) {
            if (c == '1') answer++;
        }

        System.out.println(answer);
    }
}
